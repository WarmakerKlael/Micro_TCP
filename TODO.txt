1)
Convert %d -> %u where you pass unsigned integers (like uint8_t, uint16_t, uint32_t)
Convert %d, u% -> %lu where you pass size_t integers.
Convert %d to %ld where you pass ssize_t integers.

2)
Polish all LOG messages. Some of them are ugly. Make Sure all provide useful information not just a message.
You should be able to know why you got the message and what caused it... Not just "State is wrong". Provide got and expected values, if available.

3)
For the last problem (2), you can maybe create macro that takes two parameters (got, received), and automatically converts them to 
"(%s = %d)|(%s = %d)", STRINGIFY(got), got, STRINGIFY(expected), expected.
Figure it out ... There are multiple ways to do it... find most elegant. Maybe a ned PRINT_LOG macro would be best. Suitable for such LOG messages.


Example of such print:

LOG_WARNING_RETURN(0, "Not enough space in the receive buffer, to receive syn-ack segment. (%s = %u)|(%s = %u)|(Limit = %d)",
                        STRINGIFY(_socket->buf_fill_level), _socket->buf_fill_level,
                        STRINGIFY(expected_segment_size), expected_segment_size,
                        MICROTCP_RECVBUF_LEN);

5)
Write documentation for each function /** */ style.

6)
Refine code comments.

7)
Include function that can set the print stream.

8) CHECK WHICH SECTIONS OF EACH FILE BENEFIT FROM DEBUG_MODE. put #IFNDEF DEBUG_MODE sections.


9) IF connection is closed by peer, recv should return 0, (Per recvfrom in UDP)... Check this more

10)
CHECK sequence number (in the specific check) of send_handshake_segment() and receive_handshake_segment().

11) Define different macros (or variables) for chaning TIMEOUT timer and RECVBUF of a socket. in order to increate Î¼TCP performance.

12) What's up with RST_BIT flag?

13) Let some NULL pointers cause a segmentation fault. for example INput argument pointers.


14) What's up with the `how` argument on microtcp_shutdown, implements the shutdown modes.

15) Thoughts on Phase B and receive buffer:
When you use receive, you use your receive buffer to store out-of-order packet, and packets that were half pushed into the buffer.

for example you use recvfrom. you take 1200 bytes, 800 bytes was the first segment (header+ payload) and 400 bytes part of the next segment (which will be e.g. 600 bytes)


How to avoid using circular buffers for re ordering? (Well one solution would be dynamic memory allocation, or have a pool of static buffers)


If you dont have enough space in recvbuf (rwnd) to keep the whole packet.  You keep only the bytes that can be stored, if segment complete you ack up to those number of bytes.

You have to keep track of the regions containing valid bytes. If a region is continuous the recv() forward to caller bytes from the recvbuf, instead of calling recvfrom().


16) In send_control_segment(). you can you static buffers, for microtcp_segments (you just have to initialize them). 

And a static buffer for bytestream, after you assemble segment to bytestream, you send the bytestream using sendto() (UDP) and "reset" the static buffers.
That way you avoid real time memory allocation (faster solution).


17)


        // TODO: Either use static buffer.. But this will limit you to a single socket.. Or used dynamic allocated buffer bound to each socket,
        // When you de allocate the socket, you de allocate its buffers (or during shutdown)

18) Extensively log FSMs