1)
Convert %d -> %u where you pass unsigned integers (like uint8_t, uint16_t, uint32_t)
Convert %d, u% -> %lu where you pass size_t integers.
Convert %d to %ld where you pass ssize_t integers.

2)
Polish all LOG messages. Some of them are ugly. Make Sure all provide useful information not just a message.
You should be able to know why you got the message and what caused it... Not just "State is wrong". Provide got and expected values, if available.

3)
For the last problem (2), you can maybe create macro that takes two parameters (got, received), and automatically converts them to 
"(%s = %d)|(%s = %d)", STRINGIFY(got), got, STRINGIFY(expected), expected.
Figure it out ... There are multiple ways to do it... find most elegant. Maybe a ned PRINT_LOG macro would be best. Suitable for such LOG messages.


Example of such print:

LOG_WARNING_RETURN(0, "Not enough space in the receive buffer, to receive syn-ack segment. (%s = %u)|(%s = %u)|(Limit = %d)",
                        STRINGIFY(_socket->buf_fill_level), _socket->buf_fill_level,
                        STRINGIFY(expected_segment_size), expected_segment_size,
                        MICROTCP_RECVBUF_LEN);

5)
Write documentation for each function /** */ style.

6)
Refine code comments.

7)
Include function that can set the print stream.

8) CHECK WHICH SECTIONS OF EACH FILE BENEFIT FROM DEBUG_MODE. put #IFNDEF DEBUG_MODE sections.


9) IF connection is closed by peer, recv should return 0, (Per recvfrom in UDP)... Check this more

10)
CHECK sequence number (in the specific check) of send_handshake_segment() and receive_handshake_segment().

11) >>>CHECK<<< Define different macros (or variables) for chaning TIMEOUT timer and RECVBUF of a socket. in order to increate Î¼TCP performance.

12) >>>CHECK<<< What's up with RST_BIT flag?

14) What's up with the `how` argument on microtcp_shutdown, implements the shutdown modes.

15) Thoughts on Phase B and receive buffer:
When you use receive, you use your receive buffer to store out-of-order packet, and packets that were half pushed into the buffer.

for example you use recvfrom. you take 1200 bytes, 800 bytes was the first segment (header+ payload) and 400 bytes part of the next segment (which will be e.g. 600 bytes)


How to avoid using circular buffers for re ordering? (Well one solution would be dynamic memory allocation, or have a pool of static buffers)


If you dont have enough space in recvbuf (rwnd) to keep the whole packet.  You keep only the bytes that can be stored, if segment complete you ack up to those number of bytes.

You have to keep track of the regions containing valid bytes. If a region is continuous the recv() forward to caller bytes from the recvbuf, instead of calling recvfrom().


16) >>>CHECK<<< In send_control_segment(). you can you static buffers, for microtcp_segments (you just have to initialize them). 

And a static buffer for bytestream, after you assemble segment to bytestream, you send the bytestream using sendto() (UDP) and "reset" the static buffers.
That way you avoid real time memory allocation (faster solution).


17) >>>CHECK<<<


        // TODO: Either use static buffer.. But this will limit you to a single socket.. Or used dynamic allocated buffer bound to each socket,
        // When you de allocate the socket, you de allocate its buffers (or during shutdown)

18) Extensively log FSMs

19) >>>CHECK<<<

DO YOU WANT TO SEE CLEAN FUCKING CODE IN FSMS??? AND STOP REPEATING YOUR SELF??? THEN FUCKING CONVERT IF statements to SWITCH you NOOB!!


20)
COMPLETE YOUR TODOs... You have a lot of them...

21) LOG each cases in SWITCHES in FSMs



22)
SORT #INCLUDE ROWS, in first < > second " "order grouped

23) >>>CHECK<<< RENAME RECVBUF, and the functions that init it and destroy it...


24) Create explicit loggers (One for settings, one for allocator, on microtcpGeneral) Or mehh idea?






        case RECV_SEGMENT_RST_BIT: /* Let it fall to CLOSED_1_SUBSTATE*/

                LOG_WARNING("Received a RST segment in TIME_WAIT substate. Closing connection");

        

        case RECV_SEGMENT_ERROR:

        case RECV_SEGMENT_TIMEOUT: /* Timeout occurred ; Healthy netowork case. */

                return CLOSED_1_SUBSTATE;


vs


        /* Actions on the following two cases are the same. */

        case RECV_SEGMENT_RST_BIT:

                LOG_WARNING("Received a RST segment in TIME_WAIT substate. Closing connection");        

                return CLOSED_1_SUBSTATE;

        

        case RECV_SEGMENT_ERROR:

        case RECV_SEGMENT_TIMEOUT: /* Timeout occurred ; Healthy netowork case. */

                return CLOSED_1_SUBSTATE;



25) To optimize performance, remove redundant assertions and check. After you assure code runs without errors (laughing..) put #ifdef guards. 
Let then on only ON only when  DEBUG_MODE is defined.

26) Allocator macro, can be advance (with the help of a function) to keep track of allocated memory (and its size (maybe for logging)),
and you should be able to do 
        1: print currently allocated segment.
        2: SMART_ASSERT, all memory regions are free()ed and NULLIFyied.

27) Create accessor methods (getters) to take a socket stats (sent, lost, received packers (and bytes)).

28) CHECK You can print lines to go up. not down. search it.


29)

TODO: @Note: IMPORTANT.. INTERFACE.. should ask for IP AND PORT number.
maybe different interface for Client, different for Server.


handle endianess for header. network endianess is bigendian. (your machine is litle, you phone is big), se host to network htons and 
htons and htonl (shor and long) and their opposites ntohs and ntohl. network to host


30)

When you want a data packet, you call recvfrom().

If recvfrom() returns a packet in timeout time,
then check if there is space in assembly buffer.
If There is a gap, or just free space... In any 
case if you can store some or the entire payload bytes,
and with these bytes you complete a gap,you should sent an ACK,
for "up to those bytes". Of course you must update you receive window too.

31)
huffman encoding and bitpacking.

